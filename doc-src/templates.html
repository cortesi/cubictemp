
<h1>The @!aLink("cubictemp.py.html", "Temp", "Temp")!@ Class</h1>

<p> The <b>Temp</b> class is instantiated as follows: </p>

<!--(block|pySyntax)-->
Temp(template, **kwargs)
<!--(end)-->

<p> Here <b>template</b> is the complete text of a template and <b>kwargs</b>
is a set of name/value pairs that make up the initial namespace of the
template. This initial namespace can be over-ridden by calling the template
after instantiation. So this script: </p>

<!--(block|cubescript|pySyntax)-->
template = "@_!one!@ @_!two!@."
temp = cubictemp.Temp(template, one="Hello", two="bar")
print temp(two="walrus")
<!--(end)-->

Will print:

<pre>
Hello walrus.
</pre>

<p> Temp objects can also be rendered by just "string-ifying" them, say through
a <b>print</b> statement, or a call to the built-in <b>str</b>. </p>


<!--(block|cubescript|pySyntax)-->
template = "Hello @_!foo!@."
temp = cubictemp.Temp(template, foo="bar")
s = str(temp)
print s
print temp
<!--(end)-->

Will print:

<pre>
Hello bar.
Hello bar.
</pre>


<p> <b>Temp</b> objects have a special attribute <b>name</b> that is used to
identify templates in error exceptions.You can set the template name manually
as follows:</p>

<!--(block|cubescript|pySyntax)-->
template = "@_!nonexistent!@."
temp = cubictemp.Temp(template)
temp.name = "MyName"
str(temp)
<!--(end)-->

<p>This will produce the following traceback:</p>

<!--(block|cubescript|pySyntax)-->
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/python2.5/site-packages/cubictemp.py", line 202, in __str__
    return self()
  File "/usr/lib/python2.5/site-packages/cubictemp.py", line 207, in __call__
    return self.block(**ns)
  File "/usr/lib/python2.5/site-packages/cubictemp.py", line 114, in __call__
    r = "".join([i(**ns) for i in self])
  File "/usr/lib/python2.5/site-packages/cubictemp.py", line 95, in __call__
    ret = self._eval(self._ecache, ns)
  File "/usr/lib/python2.5/site-packages/cubictemp.py", line 83, in _eval
    raise TempError(s, self.pos, self.tmpl)
cubictemp.TempError: TempError: NameError: "name 'nonexistent' is not defined"
    Context: line 1 in MyName:
        @_!nonexistent!@
        ^^^^^^^^^^^^^^^^
<!--(end)-->

<p> By default, the <b>name</b> attribute is set to "&lt;string&gt;". </p>

<p> <b>Temp</b> and <b>File</b> both have a _cubictemp_unescaped attribute set
to True. This means that neither of these object types will be escaped in
Cubictemp @!aLink("subs/definition.html", "escaped tags")!@. </p>

<h1>The @!aLink("cubictemp.py.html","File","File")!@ Class</h1>

<p> This convenience class extends Temp to ease a common usage scenario:
loading a template from a file. The File class is instantiated as follows:</p>

<!--(block | pySyntax)-->
File(path, **kwargs)
<!--(end)-->

<p> The "path" argument is the full path to a Cubictemp template. The name of
the template is set to the provided path automatically.</p>

<h1> Speed and object instantiation</h1>

<p> Cubictemp does as much work as it can at template instantiation. The
template is parsed, blocks are readied for execution, and all expressions are
pre-compiled. This means that Cubictemp is very, very fast when used in
long-running applications like FastCGI applications, where templates can be
initialised once up-front and then re-used. A nice by-product of this mode of
operation is that syntax errors are caught during the pre-compilation process,
as soon as templates are instantiated. </p>
