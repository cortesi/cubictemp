
<h1> Defining blocks </h1>

<p> Cubictemp allows you to define named blocks - that is, blocks of text that
are defined in the template body itself, and can be referenced by name anywhere
after the definition. </p>

<!--(block|cubescript|htmlSyntax)-->
<!--(_block bar)-->
    The time has come the @_!foo!@ said
    To speak of many things...
<!--(_end)-->
@_!bar!@
<!--(end)-->

<p> The template definition above declares a named block called "bar", and then
substitutes it into the page - you may think of it as similar to declaring and
then calling a Python function. Using the following piece of code:</p>

<!--(block|pySyntax)-->
print cubictemp.File(template, foo="walrus")
<!--(end)-->

<p>the template above will output:</p>

<pre>
    The time has come the walrus said
    To speak of many things...
</pre>

<p> Notice that the contents of the named block are not inserted into the
output due to the <i>definition</i> of the named block, but rather due to its
occurence in the following substitution tag. Blocks can be nested to arbitrary
depths. Block namespaces and scopes work similarly to Python namespaces and
scopes. Consider the following template:</p>

<!--(block|cubescript|htmlSyntax)-->
<!--(_block bar)-->
    <!--(_block bar)-->
    one
    <!--(_end)-->
    @_!bar!@
    two
<!--(_end)-->
@_!bar!@
<!--(_block bar)-->
    three
<!--(_end)-->
@_!bar!@
<!--(end)-->

<p> When evaluated, this will print: </p>



<pre>
    one
    two
    three
</pre>


<p> Named blocks, like <b>Template</b> and <b>File</b> objects, have the
"_cubictemp_unescaped" attribute defined by default. This means that they will
go unescaped when inserted using the standard 

<!--(block|cubescript)-->
<code class="template">@_!...!@</code> 
<!--(end)-->

escaped subsitution syntax. This arrangement makes sense when you consider that
the raw content of named blocks will almost never originate from an untrusted
source, and that blocks very commonly intentionally contain HTML. </p>


<h1> Calling blocks </h1>

<p> During the discussion templates, we noted
that a Template object can be rendered by calling it like a function. The user
can also pass a set of keyword arguments to this call, which over-rides the
namespace provided at the instantiation of the object. The same is true for
named blocks - you can call a block, and provide namespace arguments
on-the-fly. Consider the following template:</p>

<!--(block|cubescript|htmlSyntax)-->
<!--(_block bar)-->
    The time has come the @_!foo!@ said
    To speak of many things...
<!--(_end)-->
@_!bar(foo="walrus")!@

@_!bar(foo="carpenter")!@
<!--(end)-->

<p> Regardless of the arguments supplied during instantiation of the Template
object, the template above will produce the following output: </p>

<pre>
The time has come the walrus said
To speak of many things...

The time has come the carpenter said
To speak of many things...
</pre>

